# Focus APP åå°æœåŠ¡æ¶æ„è®¾è®¡

## ğŸ¯ æ ¸å¿ƒè®¾è®¡åŸåˆ™

### 1. ç”¨æˆ·è¡Œä¸ºå¯¼å‘
- **ä¸“æ³¨æœç´¢**: ç”¨æˆ·æœç´¢åç›´æ¥è¿›å…¥ç›®æ ‡APPï¼Œä¸ä¼šè¿”å›Focus
- **åå°ç›‘æ§**: Focuséœ€è¦åœ¨åå°é»˜é»˜å·¥ä½œ
- **éæ‰“æ‰°**: æé†’ä»¥æ‚¬æµ®çª—å½¢å¼æ˜¾ç¤ºï¼Œä¸å½±å“ç”¨æˆ·æ­£å¸¸ä½¿ç”¨
- **é€æ˜æ€§**: ç”¨æˆ·å¯ä»¥éšæ—¶æŸ¥çœ‹ä½¿ç”¨æ•°æ®

### 2. æŠ€æœ¯æ¶æ„è¦æ±‚
- **åå°ç¨³å®šæ€§**: ç¡®ä¿æœåŠ¡ä¸è¢«ç³»ç»Ÿæ€æ­»
- **ä½åŠŸè€—**: æœ€å°åŒ–ç”µæ± æ¶ˆè€—
- **å®æ—¶æ€§**: å‡†ç¡®çš„æ—¶é—´è¿½è¸ªå’ŒåŠæ—¶æé†’
- **å¯é æ€§**: æ•°æ®ä¸ä¸¢å¤±ï¼ŒæœåŠ¡ä¸å´©æºƒ

## ğŸ—ï¸ åå°æœåŠ¡æ¶æ„

### æ ¸å¿ƒæœåŠ¡ç»„ä»¶
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Focus åå°æœåŠ¡                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚              FocusService                           â”‚    â”‚
â”‚  â”‚              (ä¸»æœåŠ¡ - å‰å°æœåŠ¡)                    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                    â”‚                                       â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚        â”‚           â”‚           â”‚                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚UsageTrackerâ”‚ â”‚Reminderâ”‚ â”‚Overlay â”‚                    â”‚
â”‚  â”‚Service    â”‚ â”‚Service â”‚ â”‚Service â”‚                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                  æ•°æ®åŒæ­¥å±‚                           â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                    â”‚                                       â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚        â”‚           â”‚           â”‚                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚   Room    â”‚ â”‚Shared  â”‚ â”‚Work    â”‚                    â”‚
â”‚  â”‚ Database  â”‚ â”‚Prefs   â”‚ â”‚Manager â”‚                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ æ ¸å¿ƒæœåŠ¡å®ç°

### 1. FocusService (ä¸»æœåŠ¡)
```kotlin
@AndroidEntryPoint
class FocusService : Service() {
    
    private val binder = LocalBinder()
    private val usageTracker by lazy { UsageTracker(this) }
    private val reminderManager by lazy { ReminderManager(this) }
    private val overlayManager by lazy { OverlayManager(this) }
    
    inner class LocalBinder : Binder() {
        fun getService(): FocusService = this@FocusService
    }
    
    override fun onCreate() {
        super.onCreate()
        startForegroundService()
        initializeServices()
    }
    
    override fun onBind(intent: Intent): IBinder = binder
    
    private fun startForegroundService() {
        val notification = createForegroundNotification()
        startForeground(NOTIFICATION_ID, notification)
    }
    
    private fun createForegroundNotification(): Notification {
        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("Focusæ­£åœ¨è¿è¡Œ")
            .setContentText("æ­£åœ¨ç›‘æ§æ‚¨çš„ä½¿ç”¨æ—¶é—´")
            .setSmallIcon(R.drawable.ic_focus)
            .setOngoing(true)
            .build()
    }
    
    private fun initializeServices() {
        usageTracker.startTracking()
        reminderManager.startMonitoring()
        overlayManager.initialize()
    }
    
    override fun onDestroy() {
        super.onDestroy()
        usageTracker.stopTracking()
        reminderManager.stopMonitoring()
        overlayManager.cleanup()
    }
}
```

### 2. UsageTracker (ä½¿ç”¨è¿½è¸ªæœåŠ¡)
```kotlin
class UsageTracker(private val context: Context) {
    
    private val accessibilityManager by lazy {
        context.getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager
    }
    
    private val usageStatsManager by lazy {
        context.getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager
    }
    
    private val database by lazy { AppDatabase.getInstance(context) }
    
    private var isTracking = false
    private var currentSession: UsageSession? = null
    private var trackingJob: Job? = null
    
    fun startTracking() {
        if (isTracking) return
        
        isTracking = true
        trackingJob = CoroutineScope(Dispatchers.IO).launch {
            while (isTracking) {
                trackAppUsage()
                delay(1000) // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
            }
        }
    }
    
    fun stopTracking() {
        isTracking = false
        trackingJob?.cancel()
        currentSession?.let { session ->
            saveSession(session)
            currentSession = null
        }
    }
    
    private suspend fun trackAppUsage() {
        val foregroundApp = getForegroundApp()
        val supportedApps = getSupportedApps()
        
        if (foregroundApp in supportedApps) {
            if (currentSession == null) {
                // å¼€å§‹æ–°çš„ä½¿ç”¨ä¼šè¯
                currentSession = UsageSession(
                    appName = foregroundApp,
                    startTime = System.currentTimeMillis(),
                    endTime = System.currentTimeMillis()
                )
            } else {
                // æ›´æ–°å½“å‰ä¼šè¯
                currentSession?.endTime = System.currentTimeMillis()
            }
        } else {
            // ç»“æŸå½“å‰ä¼šè¯
            currentSession?.let { session ->
                saveSession(session)
                currentSession = null
            }
        }
    }
    
    private fun getForegroundApp(): String? {
        // ä½¿ç”¨UsageStatsManagerè·å–å‰å°åº”ç”¨
        val endTime = System.currentTimeMillis()
        val startTime = endTime - 1000 * 60 // 1åˆ†é’Ÿå†…
        
        val usageStats = usageStatsManager.queryUsageStats(
            UsageStatsManager.INTERVAL_DAILY,
            startTime,
            endTime
        )
        
        return usageStats
            .filter { it.lastTimeUsed == endTime }
            .maxByOrNull { it.lastTimeUsed }
            ?.packageName
    }
    
    private suspend fun saveSession(session: UsageSession) {
        database.usageDao().insertUsage(
            UsageEntity(
                appName = session.appName,
                startTime = session.startTime,
                endTime = session.endTime,
                duration = session.endTime - session.startTime
            )
        )
    }
    
    fun getTodayUsage(): Map<String, Long> {
        val todayStart = LocalDate.now().atStartOfDay(ZoneId.systemDefault())
            .toInstant().toEpochMilli()
        val todayEnd = System.currentTimeMillis()
        
        return database.usageDao().getUsageBetween(todayStart, todayEnd)
            .groupBy { it.appName }
            .mapValues { (_, entities) ->
                entities.sumOf { it.duration }
            }
    }
}

data class UsageSession(
    val appName: String,
    val startTime: Long,
    var endTime: Long
)
```

### 3. ReminderManager (æé†’ç®¡ç†æœåŠ¡)
```kotlin
class ReminderManager(private val context: Context) {
    
    private val usageTracker by lazy { UsageTracker(context) }
    private val overlayManager by lazy { OverlayManager(context) }
    private val settings by lazy { PreferenceManager.getDefaultSharedPreferences(context) }
    
    private var isMonitoring = false
    private var monitoringJob: Job? = null
    private var lastReminderTime = 0L
    
    fun startMonitoring() {
        if (isMonitoring) return
        
        isMonitoring = true
        monitoringJob = CoroutineScope(Dispatchers.Main).launch {
            while (isMonitoring) {
                checkAndTriggerReminder()
                delay(30000) // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
            }
        }
    }
    
    fun stopMonitoring() {
        isMonitoring = false
        monitoringJob?.cancel()
    }
    
    private suspend fun checkAndTriggerReminder() {
        val reminderInterval = settings.getLong("reminder_interval", 30 * 60 * 1000L) // 30åˆ†é’Ÿ
        val currentTime = System.currentTimeMillis()
        
        // æ£€æŸ¥æ˜¯å¦åœ¨"ä»Šæ—¥ä¸å†æé†’"æœŸé—´
        val dismissedUntil = settings.getLong("dismissed_until", 0L)
        if (currentTime < dismissedUntil) {
            return
        }
        
        val todayUsage = usageTracker.getTodayUsage()
        val totalUsage = todayUsage.values.sum()
        
        if (totalUsage >= reminderInterval && currentTime - lastReminderTime > reminderInterval) {
            triggerReminder(totalUsage)
            lastReminderTime = currentTime
        }
    }
    
    private fun triggerReminder(totalUsage: Long) {
        overlayManager.showReminderOverlay(totalUsage)
    }
    
    fun onUserContinue() {
        // ç”¨æˆ·é€‰æ‹©ç»§ç»­ä½¿ç”¨ï¼Œé‡ç½®è®¡æ—¶å™¨
        lastReminderTime = System.currentTimeMillis()
    }
    
    fun onUserStop() {
        // ç”¨æˆ·é€‰æ‹©åœæ­¢ä½¿ç”¨ï¼Œè®°å½•è¿™ä¸ªå†³å®š
        settings.edit().putLong("stop_until", System.currentTimeMillis() + 60 * 60 * 1000L).apply()
    }
    
    fun onDismissForToday() {
        // ç”¨æˆ·é€‰æ‹©ä»Šæ—¥ä¸å†æé†’
        val tomorrow = LocalDate.now().plusDays(1).atStartOfDay(ZoneId.systemDefault())
            .toInstant().toEpochMilli()
        settings.edit().putLong("dismissed_until", tomorrow).apply()
    }
}
```

### 4. OverlayManager (æ‚¬æµ®çª—ç®¡ç†æœåŠ¡)
```kotlin
class OverlayManager(private val context: Context) {
    
    private var windowManager: WindowManager? = null
    private var overlayView: View? = null
    private var isOverlayShown = false
    
    fun initialize() {
        windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
    }
    
    fun showReminderOverlay(totalUsage: Long) {
        if (isOverlayShown || !hasOverlayPermission()) return
        
        val layoutParams = createOverlayLayoutParams()
        overlayView = createReminderView(totalUsage)
        
        windowManager?.addView(overlayView, layoutParams)
        isOverlayShown = true
    }
    
    fun hideReminderOverlay() {
        if (!isOverlayShown) return
        
        overlayView?.let { view ->
            windowManager?.removeView(view)
            overlayView = null
        }
        isOverlayShown = false
    }
    
    private fun createOverlayLayoutParams(): WindowManager.LayoutParams {
        return WindowManager.LayoutParams(
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.WRAP_CONTENT,
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
            else
                WindowManager.LayoutParams.TYPE_PHONE,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,
            PixelFormat.TRANSLUCENT
        ).apply {
            gravity = Gravity.TOP or Gravity.CENTER_HORIZONTAL
            x = 0
            y = 100
        }
    }
    
    private fun createReminderView(totalUsage: Long): View {
        return LayoutInflater.from(context).inflate(R.layout.overlay_reminder, null).apply {
            // è®¾ç½®å†…å®¹
            findViewById<TextView>(R.id.tvUsageTime).text = formatDuration(totalUsage)
            
            // è®¾ç½®æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            findViewById<Button>(R.id.btnContinue).setOnClickListener {
                hideReminderOverlay()
                // é€šçŸ¥ReminderManagerç”¨æˆ·é€‰æ‹©ç»§ç»­
            }
            
            findViewById<Button>(R.id.btnStop).setOnClickListener {
                hideReminderOverlay()
                // é€šçŸ¥ReminderManagerç”¨æˆ·é€‰æ‹©åœæ­¢
            }
            
            findViewById<Button>(R.id.btnDismiss).setOnClickListener {
                hideReminderOverlay()
                // é€šçŸ¥ReminderManagerç”¨æˆ·é€‰æ‹©ä»Šæ—¥ä¸å†æé†’
            }
            
            // æ·»åŠ æ‹–æ‹½åŠŸèƒ½
            setOnTouchListener(OverlayTouchListener(this))
        }
    }
    
    private fun hasOverlayPermission(): Boolean {
        return Settings.canDrawOverlays(context)
    }
    
    fun cleanup() {
        hideReminderOverlay()
    }
}

class OverlayTouchListener(private val view: View) : View.OnTouchListener {
    
    private var initialX = 0
    private var initialY = 0
    private var initialTouchX = 0f
    private var initialTouchY = 0f
    
    override fun onTouch(v: View?, event: MotionEvent): Boolean {
        when (event.action) {
            MotionEvent.ACTION_DOWN -> {
                initialX = view.layoutParams.x
                initialY = view.layoutParams.y
                initialTouchX = event.rawX
                initialTouchY = event.rawY
                return true
            }
            MotionEvent.ACTION_MOVE -> {
                val dx = event.rawX - initialTouchX
                val dy = event.rawY - initialTouchY
                
                view.layoutParams.x = initialX + dx.toInt()
                view.layoutParams.y = initialY + dy.toInt()
                
                view.windowManager?.updateViewLayout(view, view.layoutParams)
                return true
            }
        }
        return false
    }
}
```

## ğŸ”„ æœåŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†

### 1. æœåŠ¡å¯åŠ¨æ—¶æœº
```kotlin
class FocusApplication : Application() {
    
    override fun onCreate() {
        super.onCreate()
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å¯åŠ¨åå°æœåŠ¡
        if (shouldStartBackgroundService()) {
            startBackgroundService()
        }
    }
    
    private fun shouldStartBackgroundService(): Boolean {
        val prefs = PreferenceManager.getDefaultSharedPreferences(this)
        return prefs.getBoolean("service_enabled", true)
    }
    
    private fun startBackgroundService() {
        val serviceIntent = Intent(this, FocusService::class.java)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            startForegroundService(serviceIntent)
        } else {
            startService(serviceIntent)
        }
    }
}
```

### 2. æœåŠ¡ä¿æ´»æœºåˆ¶
```kotlin
class FocusService : Service() {
    
    private val wakeLock: PowerManager.WakeLock by lazy {
        val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
        powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Focus::ServiceWakeLock")
    }
    
    override fun onCreate() {
        super.onCreate()
        acquireWakeLock()
        startPeriodicTasks()
    }
    
    private fun acquireWakeLock() {
        if (!wakeLock.isHeld) {
            wakeLock.acquire()
        }
    }
    
    private fun startPeriodicTasks() {
        // å®šæœŸæ£€æŸ¥æœåŠ¡çŠ¶æ€
        CoroutineScope(Dispatchers.IO).launch {
            while (true) {
                delay(60000) // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
                ensureServiceRunning()
            }
        }
    }
    
    private fun ensureServiceRunning() {
        if (!isServiceRunning()) {
            restartService()
        }
    }
    
    private fun isServiceRunning(): Boolean {
        val manager = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val services = manager.getRunningServices(Integer.MAX_VALUE)
        return services.any { it.service.className == FocusService::class.java.name }
    }
    
    private fun restartService() {
        val serviceIntent = Intent(this, FocusService::class.java)
        startService(serviceIntent)
    }
    
    override fun onDestroy() {
        super.onDestroy()
        if (wakeLock.isHeld) {
            wakeLock.release()
        }
    }
}
```

## ğŸ“Š æ•°æ®åŒæ­¥æœºåˆ¶

### 1. å®æ—¶æ•°æ®åŒæ­¥
```kotlin
class DataSyncManager(private val context: Context) {
    
    private val database by lazy { AppDatabase.getInstance(context) }
    private val usageTracker by lazy { UsageTracker(context) }
    
    suspend fun syncUsageData() {
        val latestUsage = usageTracker.getTodayUsage()
        
        // æ›´æ–°æ•°æ®åº“
        latestUsage.forEach { (appName, duration) ->
            database.usageDao().updateTodayUsage(appName, duration)
        }
        
        // é€šçŸ¥UIæ›´æ–°
        notifyUIUpdate()
    }
    
    private fun notifyUIUpdate() {
        // å‘é€å¹¿æ’­é€šçŸ¥UIæ›´æ–°
        val intent = Intent(ACTION_USAGE_UPDATED)
        context.sendBroadcast(intent)
    }
}
```

### 2. UIæ•°æ®è§‚å¯Ÿ
```kotlin
@Composable
fun observeUsageData(): StateFlow<Map<String, Long>> {
    val context = LocalContext.current
    val usageData = remember { mutableStateOf<Map<String, Long>>(emptyMap()) }
    
    DisposableEffect(context) {
        val receiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context?, intent: Intent?) {
                if (intent?.action == ACTION_USAGE_UPDATED) {
                    // é‡æ–°è·å–æ•°æ®
                    CoroutineScope(Dispatchers.IO).launch {
                        val data = UsageTracker(context!!).getTodayUsage()
                        usageData.value = data
                    }
                }
            }
        }
        
        val filter = IntentFilter(ACTION_USAGE_UPDATED)
        context.registerReceiver(receiver, filter)
        
        onDispose {
            context.unregisterReceiver(receiver)
        }
    }
    
    return usageData
}
```

## ğŸ” æƒé™ç®¡ç†

### 1. æƒé™æ£€æŸ¥å’Œç”³è¯·
```kotlin
class PermissionManager(private val context: Context) {
    
    fun checkAndRequestPermissions(): Boolean {
        return checkAccessibilityPermission() && 
               checkUsageStatsPermission() && 
               checkOverlayPermission()
    }
    
    private fun checkAccessibilityPermission(): Boolean {
        val serviceId = "${context.packageName}/.FocusService"
        val enabledServices = Settings.Secure.getString(
            context.contentResolver,
            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
        )
        return enabledServices?.contains(serviceId) == true
    }
    
    private fun checkUsageStatsPermission(): Boolean {
        val appOps = context.getSystemService(Context.APP_OPS_SERVICE) as AppOpsManager
        val mode = appOps.checkOpNoThrow(
            AppOpsManager.OPSTR_GET_USAGE_STATS,
            Process.myUid(),
            context.packageName
        )
        return mode == AppOpsManager.MODE_ALLOWED
    }
    
    private fun checkOverlayPermission(): Boolean {
        return Settings.canDrawOverlays(context)
    }
    
    fun requestPermissions() {
        // å¼•å¯¼ç”¨æˆ·åˆ°ç³»ç»Ÿè®¾ç½®é¡µé¢
        val intent = Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS)
        context.startActivity(intent)
    }
}
```

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–

### 1. ç”µæ± ä¼˜åŒ–
```kotlin
class BatteryOptimizer {
    
    fun optimizeBatteryUsage(context: Context) {
        // è¯·æ±‚å¿½ç•¥ç”µæ± ä¼˜åŒ–
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val intent = Intent()
            intent.action = Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS
            intent.data = Uri.parse("package:${context.packageName}")
            context.startActivity(intent)
        }
    }
    
    fun scheduleWork(context: Context) {
        // ä½¿ç”¨WorkManagerè¿›è¡Œå®šæœŸä»»åŠ¡
        val workRequest = PeriodicWorkRequestBuilder<UsageSyncWorker>(
            15, // 15åˆ†é’Ÿé—´éš”
            TimeUnit.MINUTES
        ).build()
        
        WorkManager.getInstance(context).enqueueUniquePeriodicWork(
            "usage_sync",
            ExistingPeriodicWorkPolicy.KEEP,
            workRequest
        )
    }
}

class UsageSyncWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        return try {
            val syncManager = DataSyncManager(applicationContext)
            syncManager.syncUsageData()
            Result.success()
        } catch (e: Exception) {
            Result.retry()
        }
    }
}
```

è¿™ä¸ªåå°æœåŠ¡æ¶æ„ç¡®ä¿äº†ï¼š
- **ç”¨æˆ·æœç´¢åä¸è¿”å›**: Focusåœ¨åå°é»˜é»˜å·¥ä½œ
- **å®æ—¶ç›‘æ§**: å‡†ç¡®è¿½è¸ªä½¿ç”¨æ—¶é•¿
- **åŠæ—¶æé†’**: æ‚¬æµ®çª—å½¢å¼ä¸æ‰“æ‰°ç”¨æˆ·
- **æ•°æ®åŒæ­¥**: UIå’ŒæœåŠ¡æ•°æ®å®æ—¶åŒæ­¥
- **æœåŠ¡ç¨³å®š**: å¤šé‡ä¿æ´»æœºåˆ¶ç¡®ä¿æœåŠ¡ä¸å´©æºƒ